/*
 Generated by Sybase Unwired Platform 
 Compiler version - 2.1.3.231
*/ 

#import "SUP101SUP101DB.h"

#import "SUP101Customer.h"
#import "SUP101Sales_order.h"
#import "SUP101Sales_order_items.h"
#import "SUP101LogRecordImpl.h"
#import "SUP101OperationReplay.h"
#import "SUP101SISSubscriptionKey.h"
#import "SUP101SISSubscription.h"
#import "SUP101PackageProperties.h"
#import "SUP101ChangeLogKey.h"
#import "SUP101ChangeLogImpl.h"
#import "SUP101OfflineAuthentication.h"
#import "SUP101KeyPackageName.h"
#import "SUP101PersonalizationParameters.h"
#import "SUP101KeyGenerator.h"
#import "SUP101KeyGeneratorPK.h"
#import "SUP101LocalKeyGenerator.h"
#import "SUP101LocalKeyGeneratorPK.h"
#import "MBODebugLogger.h"
#import "SUPEntityMessageListener.h"
#import "SUPStringList.h"
#import "SUPJsonObject.h"
#import "SUPQueueConnectionImpl.h"
#import "SUPMessageLiterals.h"
#import "SUP101LoggerImpl.h"
#import "SUPJsonString.h"
#import "SUPEntityMap.h"
#import "SUPClassMap.h"
#import "SUPSynchronizationAction.h"
#import "SUPSynchronizationGroup.h"
#import "SUPSynchronizationContext.h"
#import "SUPSynchronizationStatus.h"
#import "SUPDatabaseDelegate.h"
#import "SUPResultSetWrapper.h"
#import "SUPAbstractDBRBS.h"
#import "SUPAbstractPersonalizationParameters.h"
#import "SUPDatabaseManagerFactory.h"

@interface SUP101SUP101DB(hidden)
- (id)init;
- (id)initWithName:(NSString*)name;
// singleton
+ (SUP101SUP101DB*)instance;
+ (id)allocWithZone:(NSZone *)zone;
- (id)copyWithZone:(NSZone *)zone;
- (id)retain;
- (unsigned)retainCount;
- (void)release;
- (id)autorelease;
- (void)defineMessageListenerForEntity:(NSString*)entityName withClass:(Class)entityClass;
- (NSString*)packageVersionedPrefix;
- (BOOL)checkPending_Customer;
- (BOOL)checkPending_Sales_order;
- (BOOL)checkPending_Sales_order_items;
- (BOOL)checkPending_LogRecordImpl;
- (BOOL)checkPending_PackageProperties;
- (BOOL)checkAllReplayPending;
- (void)writeLogFromHeader:(SUPJsonObject*)o:(SUPNullableString)mbo:(SUPNullableString)method;
- (NSString *)ppmHeader;
+ (void)replay:(NSString *)mbo withId:(int64_t)counter withContent:(SUPJsonArray*)content;
+ (void)search:(NSString *)mbo withId:(int64_t)counter withContent:(SUPJsonArray*)content;
+ (void)waitForKeyGenerator;
@end
@implementation SUP101SUP101DB

static SUP101SUP101DB *instance = nil;
 
+ (SUP101SUP101DB*)instance
{
    @synchronized(self) {
        if (instance == nil) {
            // Singleton is never released
            instance = [[super allocWithZone:NULL] init];
        }
    }
    return instance;
}
 
+ (id)allocWithZone:(NSZone *)zone
{
    return [[self instance] retain];
}
 
- (id)copyWithZone:(NSZone *)zone
{
    return self;
}
 
- (id)retain
{
    return self;
}
 
- (unsigned)retainCount
{
    return NSUIntegerMax;  //denotes an object that cannot be released
}
 
- (oneway void)release
{
    //do nothing
}
 
- (id)autorelease
{
    return self;
}

+ (void)initialize
{
	[self metaData];
	[self delegate];
}

static SUPDatabaseDelegate *g_SUP101SUP101DB_delegate = nil;

+ (SUPDatabaseDelegate *) delegate
{
	@synchronized(self) {
		if (g_SUP101SUP101DB_delegate == nil) {
			g_SUP101SUP101DB_delegate = [[SUPDatabaseDelegate alloc] initWithDatabase:[self instance]];
		}
	}
	
	return [[g_SUP101SUP101DB_delegate retain] autorelease];
}

- (id)init
{
    return [self initWithName:@"SUP1011_0"];
}

- (id)initWithName:(NSString*)name;
{
    if ((self = [super initWithName:name]))
    {
        self.manager = [SUPDatabaseManagerFactory dbManagerOfType:SUPDatabaseManager_UltraLite];
    	self->_concreteSubclass = [self class];
    	
   	    [self defineMessageListenerForEntity:@"Customer" withClass:[SUP101Customer class]];
   	    [self defineMessageListenerForEntity:@"Sales_order" withClass:[SUP101Sales_order class]];
   	    [self defineMessageListenerForEntity:@"Sales_order_items" withClass:[SUP101Sales_order_items class]];
   	    [self defineMessageListenerForEntity:@"LogRecordImpl" withClass:[SUP101LogRecordImpl class]];
   	    [self defineMessageListenerForEntity:@"OperationReplay" withClass:[SUP101OperationReplay class]];
   	    [self defineMessageListenerForEntity:@"SISSubscription" withClass:[SUP101SISSubscription class]];
   	    [self defineMessageListenerForEntity:@"PackageProperties" withClass:[SUP101PackageProperties class]];
   	    [self defineMessageListenerForEntity:@"ChangeLogImpl" withClass:[SUP101ChangeLogImpl class]];
   	    [self defineMessageListenerForEntity:@"OfflineAuthentication" withClass:[SUP101OfflineAuthentication class]];
   	    [self defineMessageListenerForEntity:@"KeyGenerator" withClass:[SUP101KeyGenerator class]];

    	// set the logger
    	[self setLogger:[[[SUP101LoggerImpl alloc] init] autorelease]];
        //self.pid = [NSString stringWithFormat:@"moca://%@", [SUPMessageClient getDeviceID]];
        [self.connectionProfile setPageSize:1024];
        SUPConnectionProfile *sp = [self.connectionProfile syncProfile];
        [sp setDomainName:@"default"];
        [sp setServerName:@"WIN-9SN5AA682K5"];
        [sp setPortNumber:2480];
        [sp setNetworkProtocol:@"http,https"];
        [sp setNetworkStreamParams:@"trusted_certificates=;url_suffix="];
        [sp applyPropertiesFromApplication];
 	}

    return self;
    
}

- (void)defineMessageListenerForEntity:(NSString*)entityName withClass:(Class)entityClass
{
    SUPEntityMessageListener* listener = [[SUPEntityMessageListener alloc] initWithClass:entityClass];
    [listener autorelease];
    [_messageListenerMap add:(id)entityName:(id)listener];
}

- (NSString*)packageVersionedPrefix
{
	return @"SUP101:1.0";
}

- (NSString*)syncParamsVersion
{
    return [NSString stringWithFormat:@"%@_sup101.1_0", [[self class] getDomainName]];
}

+ (NSString*)getSyncUsername
{
    return [[self delegate] getSyncUsername];
}

+ (NSString*)getPackageName
{
	return [[self instance] packageVersionedPrefix];
}

+ (NSString*)getDomainName
{
	return [[self delegate] getDomainName];
}

+ (NSString*)defaultDomainName
{
	return @"default";
}

+ (int32_t)getSchemaVersion
{
	return [[self delegate] getSchemaVersion];
}

+ (int32_t)getProtocolVersion
{
	return [[self delegate] getProtocolVersion];
}

static SUPDatabaseMetaDataRBS* SUP101SUP101DB_META_DATA;
static BOOL _valid_ = NO;

+ (SUPDatabaseMetaDataRBS*)metaData
{
    if (! (_valid_))
    {
		SUP101SUP101DB_META_DATA = [[SUP101SUP101DBMetaData alloc] init];
     	_valid_ = YES;
	}
	
	return SUP101SUP101DB_META_DATA;
}

+ (SUP101PersonalizationParameters*)getPersonalizationParameters
{
    return (SUP101PersonalizationParameters*)( ((SUPDatabaseDelegate *)[self delegate]).personalizationParameters);
}

- (NSObject<SUPQueueConnection>*)queueConnection
{
    if (_queueConnection == nil)
    {
        self.queueConnection = [SUPQueueConnectionImpl getInstance:nil withPackage:@"SUP101:1.0"];
    }
    return _queueConnection;
}

+ (id<SUPReadWriteLockManager>)dblock
{
    return [[self instance] dblock];
}
+ (SUPLocalTransaction*)beginTransaction
{
    return [[self instance] beginTransaction];
}

+ (NSObject<SUPCallbackHandler>*)callbackHandler
{
    return [[self instance] callbackHandler];
}

+ (SUPConnectionProfile*)connectionProfile
{
    return [[self instance] connectionProfile];
}

+ (SUPConnectionProfile*)getConnectionProfile
{
    return [[self instance] connectionProfile];
}

+ (SUPConnectionProfile*)getSynchronizationProfile
{
    return [[[self instance] connectionProfile] syncProfile];
}

+ (void)checkIfSubscribed
{
	if(([[self instance] packageIsSubscribed]) || ([[self instance] packageIsSubscribePending]))
		return;
	else
		@throw [SUPPersistenceException withMessage:@"Package is not subscribed"];
}

+ (void)clearConnection
{
    [[self instance] clearConnection];
    [[self instance] setManager:nil];
}

+ (void)createDatabase
{
    [[SUP101SUP101DB delegate] createDatabase];
}

+ (void)deleteDatabase
{
    [[self instance] deleteDatabase];
}

+ (BOOL)databaseExists
{
    return [[self instance] databaseExists];
}

+ (id<SUPConnectionWrapper>)getConnectionWrapper
{
    return [[self instance] getConnectionWrapper];
}

+ (void)openConnection
{
    [[self instance] getConnectionWrapper];
}

+ (void)closeConnection
{
    [[self instance] closeConnection];
    [[self instance] setManager:nil];
}

+ (id<SUPLogger>)getLogger
{
	return [[self instance] logger];
}

+ (id<SUPSynchronizationGroup>) getSynchronizationGroup:(NSString*)syncGroup
{
    return [g_SUP101SUP101DB_delegate getSynchronizationGroup:syncGroup];
}

+ (SUPQueryResultSet*)executeQuery:(SUPQuery*)query
{
	return [[self instance] executeQuery:[self metaData] query:query];
}

+ (void)onMessage:(SUPJsonMessage*)message
{
    [[self instance] onMessage:message];
}

+ (BOOL)packageHasSubscription
{
	return (([[self instance] packageIsSubscribed]) || ([[self instance] packageIsSubscribePending]))
	;
}

+ (id<SUPQueueConnection>)queueConnection
{
    return [[self instance] queueConnection];
}

+ (void)recover
{
    [[self instance] recover];
}

+ (void)registerCallbackHandler:(NSObject<SUPCallbackHandler>*)handler
{
    [[self instance] registerCallbackHandler:handler];
}

+ (void)resumeSubscription
{
    [[self instance] resume];
}

+ (void)setApplication:(SUPApplication*)application
{
    [[self instance] startBackgroundSynchronization];
}

+ (void)startBackgroundSynchronization
{
    [[self instance] startBackgroundSynchronization];
}

+ (void)stopBackgroundSynchronization
{
    [[self instance] stopBackgroundSynchronization];
}

+ (void)submitPendingOperations
{
	[self submitPendingOperations:nil];
}

+ (void)submitPendingOperations:(NSString*)synchronizationGroup
{
	[[SUP101SUP101DB delegate] submitPendingOperations:synchronizationGroup];
}

+ (void)cancelPendingOperations
{
	[self cancelPendingOperations:nil];
}

+ (void)cancelPendingOperations:(NSString*)synchronizationGroup
{
	[[SUP101SUP101DB delegate] cancelPendingOperations:synchronizationGroup];
}

+ (void)subscribe
{
	[[self delegate] subscribe];
}

+ (void)beginSynchronize:(SUPObjectList*)synchronizationGroups withContext:(NSString*)context withUploadOnly:(BOOL) uploadOnly
{
	[[self delegate] beginSynchronizeForGroups:synchronizationGroups withContext:context withUploadOnly:uploadOnly];
}

+ (void)beginSynchronize:(SUPObjectList*)synchronizationGroups withContext:(NSString*)context;
{
	[[self delegate] beginSynchronizeForGroups:synchronizationGroups withContext:context];
}

+ (void)suspendSubscription
{
    [[self delegate] suspendSubscription];
}

+ (void)unsubscribe
{
    [[self delegate] unsubscribe];
}

+ (void)replay:(NSString *)mbo withId:(int64_t)counter withContent:(SUPJsonArray*)content
{
    [[self instance] replay:mbo withId:counter withContent:content];
}

+ (void)search:(NSString *)mbo withId:(int64_t)counter withContent:(SUPJsonArray*)content
{
    [[self instance] search:mbo withId:counter withContent:content];
}

+ (void)setNeedSync
{
    [[self instance] setNeedSync];
}

+ (void)synchronizeIfNeeded
{
    [[self instance] synchronizeIfNeeded];
}

+ (BOOL)hasPendingOperations
{
	return [[self instance] checkAllReplayPending];
}

+ (void)synchronize
{
    
	[[self delegate] synchronize];
}
+ (void)synchronize:(NSString*)synchronizationGroup
{
    [[self delegate] synchronize:synchronizationGroup];
}
+ (void)synchronizeWithListener:(id<SUPSyncStatusListener>) listener
{
    [[self delegate] synchronizeWithListener:listener];
}
+ (void)synchronize:(NSString *)synchronizationGroup withListener:(id<SUPSyncStatusListener>)listener
{
    [[self delegate] synchronize:synchronizationGroup withListener:listener];
}

+ (SUPOnlineLoginStatus*)getOnlineLoginStatus
{
	
	[self doesNotRecognizeSelector:_cmd];
	return nil;
	// this is for MBS
	//return [[self instance] onlineLoginStatus];
}

+ (void)generateEncryptionKey
{
    [[self delegate] generateEncryptionKey];
}

+ (void)changeEncryptionKey:(NSString *)newKey
{
    [[self instance] changeEncryptionKey:newKey];
}

+ (void)cleanAllData:(BOOL) keepClientOnly
{
	[[self delegate] cleanAllData:keepClientOnly];
}

+ (void)cleanAllData
{
	[[self delegate] cleanAllData];
}
/* not supported RBS
+ (BOOL)isSubscribed
{
	return ([[self instance] packageIsSubscribed] || [[self instance] packageIsSubscribePending]);
}
*/
+ (BOOL) isReplayQueueEmpty
{
	return [[self delegate] isReplayQueueEmpty];
}
+ (SUPObjectList*) getBackgroundSyncRequests
{
	return [[self delegate] getBackgroundSyncRequests];
}

+ (void) enableChangeLog
{
    [[self getSynchronizationProfile] setString:@"changeLogEnabled":@"true"];
}

+ (void) disableChangeLog
{
    [[self getSynchronizationProfile] setString:@"changeLogEnabled":@"false"];
}

+ (SUPObjectList*) getChangeLogs:(SUPQuery*)query
{
   return [[self delegate] getChangeLogs:query];
}

+ (void) deleteChangeLogs
{
    return [SUP101ChangeLogImpl deleteChangeLogs];
}

+ (void) onlineLogin
{
 
        NSString *username = [[self getSynchronizationProfile] getUser];
        NSString *password = [[self getSynchronizationProfile] getPassword];
        [[self delegate] onlineLogin:username password:password];   
}

+ (void)writeLogFromHeader:(SUPJsonObject*)o:(SUPNullableString)mbo:(SUPNullableString)method
{
#if 0
	// if server sent level attribute as string, change it to integer before reading JSON
	id levelObject = [o item:@"level"];
    if (((levelObject != nil)) && ([levelObject isKindOfClass:[SUPJsonString class]]))
    {
        SUPJsonString* js = ((SUPJsonString*)(levelObject));
        [o setInt:@"level":[SUPLogLevel fromString:js.value]];
    }
	SUP101LogRecordImpl *log = [[SUP101LogRecordImpl alloc] initFromJson:o :0];
	if (!([o containsKey:@"messageId"]))
	{
		SUPObjectList *klist = [SUP101KeyGenerator findAll];
		if([klist size] > 0)
			log.messageId = [SUP101KeyGenerator generateId];
		else
			log.messageId = [SUP101LocalKeyGenerator generateId];
	}
	if(log.component == nil) log.component = ((mbo != nil) ? mbo : @"SUP101DB");
	if(log.operation == nil) log.operation = method;
	if(log.requestId == nil) log.requestId = [NSString stringWithFormat:@"%ld",log.messageId];
	if(log.timestamp == nil) log.timestamp = [[NSDate alloc] initWithTimeIntervalSinceNow:0];
	[log createPending:NO];
	[log autorelease];
#endif
}

+ (SUPObjectList*)getLogRecords:(SUPQuery*)query
{
	// If query is nil, create an empty one and findWithQuery will get all the records
	if(query == nil)
		query = [SUPQuery getInstance];
    return (SUPObjectList*)[SUP101LogRecordImpl findWithQuery:query];
}

+ (void)submitLogRecords
{
    [SUP101LogRecordImpl submitPendingOperations];
}

- (void)createDatabase
{
	[[SUP101SUP101DB delegate] createDatabase];
}

- (BOOL)checkPending_Customer
{  
    return NO;
}
- (BOOL)checkPending_Sales_order
{  
    return NO;
}
- (BOOL)checkPending_Sales_order_items
{  
    return NO;
}
- (BOOL)checkPending_LogRecordImpl
{  
    return NO;
}
- (BOOL)checkPending_PackageProperties
{  
    return NO;
}
- (BOOL)checkAllReplayPending
{
    BOOL wait = NO;
    if (wait == NO) {    
        wait =[self checkPending_Customer];
    }
    if (wait == NO) {    
        wait =[self checkPending_Sales_order];
    }
    if (wait == NO) {    
        wait =[self checkPending_Sales_order_items];
    }
    if (wait == NO) {    
        wait =[self checkPending_LogRecordImpl];
    }
    if (wait == NO) {    
        wait =[self checkPending_PackageProperties];
    }
    return wait;
}

- (BOOL)packageIsSubscribed
{
    return NO;
}

- (BOOL)packageIsSubscribePending
{
    return NO;
}

- (BOOL)packageIsSuspended
{
    return NO;
}

- (BOOL)packageIsResumed
{
    return NO;
}

- (void)recordSubscriptionStatus:(SUPJsonMessage*)message
{
}

- (void)trackSubscriptionStatusOnMethod:(SUPString)method andRequestID:(SUPLong)counter
{
}

- (void)clearSubscriptionStatus
{
}

- (NSString *)ppmHeader
{
    SUPJsonObject *json = [[SUPJsonObject alloc] init];
    SUPAbstractPersonalizationParameters *pp = [[SUP101SUP101DB delegate] personalizationParameters];
        NSDictionary *keyMap = [pp getAllPersonalizationKeys];
    for (id keyName in [keyMap allKeys])
    {
        [json setNullableString:keyName:[keyMap objectForKey:keyName]];
    }    
    NSData *bin = [SUPStringUtil toUTF8:[json toString]];
    [json autorelease];
    return ([SUPBase64Encoding encode:bin]);
}

#if 0
- (SUPStringList *)authParam:(NSString*)synchronizationGroup
{
    SUPJsonObject *json = [[SUPJsonObject alloc] init];;
    SUP101PersonalizationParameters* pp = [SUP101SUP101DB getPersonalizationParameters];;

    SUPObjectList * listSessionPersonalization = pp.listSessionPK;;
    for(SUP101SessionPersonalization* p in listSessionPersonalization)
    {
        [json setNullableString:p.key_name:p.value];;
    }
    [json setString:@"publications":synchronizationGroup];
    [json setString:@"pv":[[NSNumber numberWithInt:[[self class] getProtocolVersion]] description]]; 
    [json setString:@"pid":self.pid];
    [json setString:@"app":self.appName];
    
    SUPConnectionProfile *sp = [[self class] getSynchronizationProfile];    
    [json setString:@"cle" :[sp getStringWithDefault:@"changeLogEnabled" :@"false"]];
    
    BOOL isInitialSync = [synchronizationGroup isEqualToString:@"initialSync"];
    BOOL async = !isInitialSync && [sp getBooleanWithDefault:@"asyncReplay" :YES];

    [json setString:@"_as" :[SUPStringUtil toString_boolean:async]];

    [json setString:@"os":[NSString stringWithFormat:@"%@ %@",[[UIDevice currentDevice] systemName],[[UIDevice currentDevice] systemVersion]]];

    NSData *bin = [SUPStringUtil toUTF8:[json toString]];
    NSString *authParam = [SUPBase64Encoding encode:bin];

    [json autorelease];

    int maxLen = 128;
    int size = ([authParam length] + maxLen - 1) / maxLen;
    if (size > 16)
    {
       @throw [NSException exceptionWithName:@"authParam error" reason:@"the length of personalization parameters exceeds the limit of authenticate parameters and the safe length is 512 bytes" userInfo:nil];
    }
    SUPStringList *authList = [SUPStringList listWithCapacity:16];
    for (int i = 0; i < size; i++)
    {
        
        [authList add:[authParam substringWithRange:NSMakeRange(i*maxLen, ((i + 1) * maxLen < [authParam length]) ? maxLen : ([authParam length] - i * maxLen))]];
    }
    for (int i = size; i < 16; i++)
    {
        [authList add:@"x"]; // spacer
    }

    return (authList);
}
#endif

- (NSMutableDictionary*)getTableMBOMap
{
    NSMutableDictionary *map = [[[NSMutableDictionary alloc] init] autorelease];
    [map setObject:@"Customer" forKey:@"sup101_1_0_customer"];;
    [map setObject:@"Sales_order" forKey:@"sup101_1_0_sales_order"];;
    [map setObject:@"Sales_order_items" forKey:@"sup101_1_0_sales_order_items"];;
    [map setObject:@"LogRecordImpl" forKey:@"sup101_1_0_logrecordimpl"];;
    [map setObject:@"OperationReplay" forKey:@"sup101_1_0_operationreplay"];;
    [map setObject:@"SISSubscription" forKey:@"sup_sis_subscription"];;
    [map setObject:@"PackageProperties" forKey:@"sup101_1_0_packageproperties"];;
    [map setObject:@"ChangeLogImpl" forKey:@"sup101_1_0_changelogimpl"];;
    [map setObject:@"OfflineAuthentication" forKey:@"co_sup101_1_0_offlineauthentication"];;
    [map setObject:@"KeyGenerator" forKey:@"sup101_1_0_keygenerator"];;
    [map setObject:@"LocalKeyGenerator" forKey:@"co_sup101_1_0_localkeygenerator"];;
    
    return map;
}

@end